<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title data-i18n="title">–ì—Ä–∞ "–°–∫—Ä–∏–Ω—å–∫–∏"</title>
  <style>
     /* --- –ê–¥–∞–ø—Ç–æ–≤–∞–Ω—ñ —Å—Ç–∏–ª—ñ --- */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

    body {
        font-family: 'Inter', sans-serif;
        background-color: #1a1a2e;
        color: #e0e0e0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
    }
    .game-container {
        background-color: #2e2c4d;
        border-radius: 12px;
        padding: 40px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        text-align: center;
        width: 90%;
        max-width: 800px;
    }
    h1 {
        font-size: 2.5rem;
        color: #e94560;
        margin-bottom: 20px;
    }
    h3 {
        color: #e94560;
        margin-top: 20px;
    }
    p {
        font-size: 1.2rem;
        line-height: 1.6;
        margin: 10px 0;
    }
    button, .suit-btn {
        background-color: #55a630;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        margin: 5px;
        transition: background-color 0.3s ease;
    }
    button:hover, .suit-btn:hover {
        background-color: #408823;
    }
    button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
    }
    .suit-btn {
        font-size: 20px;
        width: 40px;
        height: 40px;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 0;
    }
    .card {
        background-color: #e0e0e0;
        border: 1px solid #4a4a6b;
        border-radius: 8px;
        padding: 8px;
        width: 60px;
        height: 80px;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        margin: 5px;
        cursor: pointer;
    }
    .card.selected {
        background-color: #55a630;
        border-color: #c3e6cb;
        color: white;
    }
    .hearts, .diamonds { 
        color: #d32f2f; 
    }
    .clubs, .spades { 
        color: #000000;
    }
    .card.selected.hearts, .card.selected.diamonds {
        color: white;
    }
    .card.selected.clubs, .card.selected.spades {
        color: white;
    }

    .box {
        background-color: #e94560;
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        margin: 5px;
        font-weight: bold;
        display: inline-block;
    }
    
    #game-rules {
        text-align: left;
        padding: 20px;
        border-radius: 12px;
        background-color: #12122b;
        border: 1px solid #444;
        margin-top: 20px;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.6);
    }
    #game-rules ol {
        padding-left: 20px;
    }
    #game-rules li {
        margin-bottom: 10px;
    }
    .controls {
        margin: 20px 0; 
        padding: 20px; 
        background-color: #12122b; 
        border-radius: 12px;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.6);
    }

    /* –ñ—É—Ä–Ω–∞–ª –≥—Ä–∏ */
    .game-log {
        text-align: left;
        max-height: 200px;
        overflow-y: auto;
        border-radius: 12px;
        background-color: #12122b;
        border: 1px solid #444;
        padding: 10px;
        margin-top: 20px;
        font-size: 0.95rem;
        line-height: 1.4;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.6);
    }
    .log-entry {
        margin: 5px 0;
        padding: 4px 8px;
        background-color: rgba(255,255,255,0.05);
        border-left: 3px solid #e94560;
    }
    .player-log { 
        color: #e0e0e0; 
        border-left-color: #55a630;
    }
    .bot-log { 
        color: #e0e0e0;
        border-left-color: #e94560;
    }
    .system-log { 
        color: #28a745; 
        font-weight: bold;
        border-left-color: #28a745;
    }
    
    .modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
    }
    .modal-content {
        background-color: #2e2c4d;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #4a4a6b;
        width: 80%;
        max-width: 500px;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    .close {
        color: #e0e0e0;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }
    .close:hover {
        color: #fff;
    }

  </style>
</head>
<body>
  <div class="game-container">
    <div class="lang-switcher">
        <label for="lang-select">üåç</label>
        <select id="lang-select">
            <option value="en">English</option>
            <option value="uk">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
            <option value="de">Deutsch</option>
            <option value="ru">–†—É—Å—Å–∫–∏–π</option>
            <option value="es">Espa√±ol</option>
        </select>
    </div>
    <h1 data-i18n="gameTitle"></h1>

    <div class="game-info">
      <h3 data-i18n="gameInfo"></h3>
      <p><span data-i18n="currentPlayer"></span> <span id="current-player"></span></p>
      <p><span data-i18n="playerBoxes"></span> <span id="player-boxes">0</span> (<span id="player-boxes-list"></span>)</p>
      <p><span data-i18n="botBoxes"></span> <span id="bot-boxes">0</span> (<span id="bot-boxes-list"></span>)</p>
      <p><span data-i18n="deckCount"></span> <span id="deck-count">36</span></p>
    </div>

    <div id="player-hand">
      <h3 data-i18n="yourCards"></h3>
      <div id="player-cards" class="card-container"></div>
    </div>

    <div class="controls" id="game-controls">
      <h3 data-i18n="controls"></h3>
      <div id="rank-selection">
        <p data-i18n="rankSelection"></p>
        <div id="rank-buttons"></div>
      </div>

      <div id="count-selection" style="display: none;">
        <p data-i18n="countSelection"></p>
        <button class="count-btn" data-count="1">1</button>
        <button class="count-btn" data-count="2">2</button>
        <button class="count-btn" data-count="3">3</button>
        <button class="count-btn" data-count="4">4</button>
      </div>

      <div id="suit-selection" style="display: none;">
        <p data-i18n="suitSelection"></p>
        <button class="suit-btn hearts" data-suit="‚ô•">‚ô•</button>
        <button class="suit-btn diamonds" data-suit="‚ô¶">‚ô¶</button>
        <button class="suit-btn clubs" data-suit="‚ô£">‚ô£</button>
        <button class="suit-btn spades" data-suit="‚ô†">‚ô†</button>
        <div id="selected-suits"></div>
        <button id="submit-request" disabled data-i18n="submitRequest"></button>
      </div>
    </div>

    <div id="bot-turn-info" style="display: none;">
      <h3 data-i18n="botTurnInfo"></h3>
      <div id="bot-messages"></div>
    </div>

    <div class="game-log">
      <h3 data-i18n="gameHistory"></h3>
      <div id="game-history"></div>
    </div>

    <div id="game-rules">
      <h3 data-i18n="gameRules"></h3>
      <ol>
        <li data-i18n="rule1"></li>
        <li data-i18n="rule2"></li>
        <li data-i18n="rule3"></li>
        <li data-i18n="rule4"></li>
        <li data-i18n="rule5"></li>
      </ol>
    </div>

    <button id="new-game-btn" data-i18n="newGame"></button>
    <button id="send-result-to-bot" style="display:none;" data-i18n="sendResult"></button>
  </div>

  <div id="game-over-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2 data-i18n="gameOver"></h2>
      <div id="game-result"></div>
      <button id="play-again-btn" data-i18n="playAgain"></button>
    </div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <script>
    const translations = {
      en: {
        title: "The Boxes Game",
        player: "Player",
        bot: "Bot",
        gameTitle: "The Boxes Game",
        gameInfo: "Game Information",
        currentPlayer: "Current Player:",
        playerBoxes: "Player's Boxes:",
        botBoxes: "Bot's Boxes:",
        deckCount: "Cards in Deck:",
        yourCards: "Your Cards:",
        controls: "Controls",
        rankSelection: "Choose the rank of the card you want to request:",
        countSelection: "Choose the number of cards:",
        suitSelection: "Choose the suits:",
        selectedSuits: "Selected suits:",
        submitRequest: "Submit Request",
        botTurnInfo: "Bot's Turn...",
        gameHistory: "Game History:",
        gameRules: "Game Rules:",
        rule1: "The goal of the game is to collect as many 'boxes' (4 cards of the same rank) as possible.",
        rule2: "Ask the bot for cards of a certain rank, count, and suit.",
        rule3: "If you guess correctly, continue your turn until you make a mistake.",
        rule4: "If not, the turn passes to the bot.",
        rule5: "The game ends when all 9 boxes are collected or when there are no more cards.",
        newGame: "New Game",
        sendResult: "Send Result to Bot",
        gameOver: "Game Over!",
        playAgain: "Play Again",
        gameStarted: "Game started!",
        initialCardsDealt: "Initial cards dealt to players",
        playerCollectedBox: "You collected a box of {rank}!",
        botCollectedBox: "The bot collected a box of {rank}!",
        playerAsk: "Player asked for cards of rank {rank}",
        playerAskCount: "Player asked for {count} cards of rank {rank}",
        playerChoseSuits: "Player chose suits: {suits}",
        botAsk: "Bot asks: \"Do you have {rank}?\"",
        botAskCount: "Bot asks: \"Do you have {count} {rank}?\"",
        botAskSuits: "Bot asks: \"Do you have {count} {rank} of suits {suits}?\"",
        botTurnThinking: "ü§ñ The bot is thinking about its move...",
        botDrawsFromDeck: "ü§ñ Bot received a card from the deck.",
        playerDrewFromDeck: "You took a card from the deck: {card}",
        botNoCards: "You don't have those cards.",
        botDrawsFromDeckMessage: "üì© Bot received a card from the deck.",
        playerMistakeCount: "You made a mistake! The bot has {count} of rank {rank}.",
        playerMistakeSuits: "You made a mistake!",
        noMoreCardsInDeck: "There are no more cards in the deck.",
        playerGuessed: "üéâ You guessed correctly! The bot gave you: {cards}",
        yourNewCards: "üìã Your new cards: {cards}",
        playerNoCardsDraw: "üÉè You have no cards left. You took a card: {card}",
        playerNoCardsNoDeck: "üÉè You have no cards and the deck is empty.",
        botGuessed: "üéØ The bot guessed correctly! You give up: {cards}",
        botCards: "Bot's cards:",
        botNoCardsInHand: "ü§ñ The bot had no cards.",
        allBoxesCollected: "ü§ñ All boxes have been collected!",
        errorWebApp: "WebApp API is not available - the page is not opened via Telegram.",
        resultSent: "Result sent to bot ‚úÖ",
        errorSending: "Error sending result to bot.",
        results: "Results:",
        winner: "Winner:",
        gameOverWinner: "Game Over! Winner: {winner} with {boxes} boxes",
        playerTookCards: "Player took cards from {fromPlayer}: {cards}",
        botTookCards: "Bot took cards from {fromPlayer}: {cards}",
        botTurn: "Bot's turn...",
        playerTookFromDeck: "Player took a card from the deck: {card}",
        youGuessed: "You guessed correctly!",
        youMadeAMistake: "You made a mistake!",
        botPassedTurn: "The turn passes to the bot.",
        deckEmpty: "The deck is empty."
      },
      uk: {
        title: "–ì—Ä–∞ '–°–∫—Ä–∏–Ω—å–∫–∏'",
        player: "–ì—Ä–∞–≤–µ—Ü—å",
        bot: "–ë–æ—Ç",
        gameTitle: "–ì—Ä–∞ '–°–∫—Ä–∏–Ω—å–∫–∏'",
        gameInfo: "–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –≥—Ä—É",
        currentPlayer: "–ü–æ—Ç–æ—á–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å:",
        playerBoxes: "–°–∫—Ä–∏–Ω—å–∫–∏ –≥—Ä–∞–≤—Ü—è:",
        botBoxes: "–°–∫—Ä–∏–Ω—å–∫–∏ –±–æ—Ç–∞:",
        deckCount: "–ö–∞—Ä—Ç —É –∫–æ–ª–æ–¥—ñ:",
        yourCards: "–í–∞—à—ñ –∫–∞—Ä—Ç–∏:",
        controls: "–£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è",
        rankSelection: "–û–±–µ—Ä—ñ—Ç—å –Ω–æ–º—ñ–Ω–∞–ª –∫–∞—Ä—Ç–∏, —è–∫—É —Ö–æ—á–µ—Ç–µ –∑–∞–ø—Ä–æ—Å–∏—Ç–∏:",
        countSelection: "–û–±–µ—Ä—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–∞—Ä—Ç:",
        suitSelection: "–û–±–µ—Ä—ñ—Ç—å –º–∞—Å—Ç—ñ:",
        selectedSuits: "–í–∏–±—Ä–∞–Ω–æ –º–∞—Å—Ç–µ–π:",
        submitRequest: "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –∑–∞–ø–∏—Ç",
        botTurnInfo: "–•—ñ–¥ –±–æ—Ç–∞...",
        gameHistory: "–Ü—Å—Ç–æ—Ä—ñ—è –≥—Ä–∏:",
        gameRules: "–ü—Ä–∞–≤–∏–ª–∞ –≥—Ä–∏:",
        rule1: "–ú–µ—Ç–∞ –≥—Ä–∏ - –∑—ñ–±—Ä–∞—Ç–∏ —è–∫–Ω–∞–π–±—ñ–ª—å—à–µ '—Å–∫—Ä–∏–Ω—å–æ–∫' (4 –∫–∞—Ä—Ç–∏ –æ–¥–Ω–æ–≥–æ –Ω–æ–º—ñ–Ω–∞–ª—É).",
        rule2: "–ó–∞–ø–∏—Ç—É–π—Ç–µ —É –±–æ—Ç–∞ –∫–∞—Ä—Ç–∏ –ø–µ–≤–Ω–æ–≥–æ –Ω–æ–º—ñ–Ω–∞–ª—É, –∫—ñ–ª—å–∫–æ—Å—Ç—ñ —Ç–∞ –º–∞—Å—Ç—ñ.",
        rule3: "–Ø–∫—â–æ –≤–∏ –≤–≥–∞–¥–∞–ª–∏, –ø—Ä–æ–¥–æ–≤–∂—É–π—Ç–µ —Ö–æ–¥–∏—Ç–∏, –ø–æ–∫–∏ –Ω–µ –ø–æ–º–∏–ª–∏—Ç–µ—Å—å.",
        rule4: "–Ø–∫—â–æ –Ω—ñ - —Ö—ñ–¥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –¥–æ –±–æ—Ç–∞.",
        rule5: "–ì—Ä–∞ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è, –∫–æ–ª–∏ –∑—ñ–±—Ä–∞–Ω–æ –≤—Å—ñ 9 —Å–∫—Ä–∏–Ω—å–æ–∫ –∞–±–æ –∫–æ–ª–∏ –∑–∞–∫—ñ–Ω—á–∏–ª–∏—Å—è –∫–∞—Ä—Ç–∏.",
        newGame: "–ù–æ–≤–∞ –≥—Ä–∞",
        sendResult: "–ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±–æ—Ç—É",
        gameOver: "–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!",
        playAgain: "–ì—Ä–∞—Ç–∏ –∑–Ω–æ–≤—É",
        gameStarted: "–ì—Ä–∞ —Ä–æ–∑–ø–æ—á–∞–ª–∞—Å—è!",
        initialCardsDealt: "–†–æ–∑–¥–∞–Ω–æ –ø–æ—á–∞—Ç–∫–æ–≤—ñ –∫–∞—Ä—Ç–∏ –≥—Ä–∞–≤—Ü—è–º",
        playerCollectedBox: "–í–∏ –∑—ñ–±—Ä–∞–ª–∏ —Å–∫—Ä–∏–Ω—å–∫—É {rank}!",
        botCollectedBox: "–ë–æ—Ç –∑—ñ–±—Ä–∞–≤ —Å–∫—Ä–∏–Ω—å–∫—É {rank}!",
        playerAsk: "–ì—Ä–∞–≤–µ—Ü—å –∑–∞–ø–∏—Ç–∞–≤ –∫–∞—Ä—Ç–∏ {rank}",
        playerAskCount: "–ì—Ä–∞–≤–µ—Ü—å –∑–∞–ø–∏—Ç–∞–≤ {count} –∫–∞—Ä—Ç–∏ {rank}",
        playerChoseSuits: "–ì—Ä–∞–≤–µ—Ü—å –≤–∏–±—Ä–∞–≤ –º–∞—Å—Ç—ñ: {suits}",
        botAsk: "–ë–æ—Ç –∑–∞–ø–∏—Ç—É—î: \"–£ –≤–∞—Å —î {rank}?\"",
        botAskCount: "–ë–æ—Ç –∑–∞–ø–∏—Ç—É—î: \"–£ –≤–∞—Å —î {count} {rank}?\"",
        botAskSuits: "–ë–æ—Ç –∑–∞–ø–∏—Ç—É—î: \"–£ –≤–∞—Å —î {count} {rank} –º–∞—Å—Ç–µ–π {suits}?\"",
        botTurnThinking: "ü§ñ –ë–æ—Ç –æ–±–¥—É–º—É—î —Å–≤—ñ–π —Ö—ñ–¥...",
        botDrawsFromDeck: "ü§ñ –ë–æ—Ç –æ—Ç—Ä–∏–º–∞–≤ –∫–∞—Ä—Ç—É –∑ –∫–æ–ª–æ–¥–∏.",
        playerDrewFromDeck: "–í–∏ –≤–∑—è–ª–∏ –∫–∞—Ä—Ç—É –∑ –∫–æ–ª–æ–¥–∏: {card}",
        botNoCards: "–£ –≤–∞—Å –Ω–µ–º–∞—î —Ç–∞–∫–∏—Ö –∫–∞—Ä—Ç.",
        botDrawsFromDeckMessage: "üì© –ë–æ—Ç –æ—Ç—Ä–∏–º–∞–≤ –∫–∞—Ä—Ç—É –∑ –∫–æ–ª–æ–¥–∏.",
        playerMistakeCount: "–í–∏ –ø–æ–º–∏–ª–∏–ª–∏—Å—å! –£ –±–æ—Ç–∞ {count} {rank}.",
        playerMistakeSuits: "–í–∏ –ø–æ–º–∏–ª–∏–ª–∏—Å—å!",
        noMoreCardsInDeck: "–í –∫–æ–ª–æ–¥—ñ –±—ñ–ª—å—à–µ –Ω–µ–º–∞—î –∫–∞—Ä—Ç.",
        playerGuessed: "üéâ –í–∏ –≤–≥–∞–¥–∞–ª–∏! –ë–æ—Ç –≤—ñ–¥–¥–∞–≤ –≤–∞–º: {cards}",
        yourNewCards: "üìã –í–∞—à—ñ –Ω–æ–≤—ñ –∫–∞—Ä—Ç–∏: {cards}",
        playerNoCardsDraw: "üÉè –£ –≤–∞—Å –Ω–µ –∑–∞–ª–∏—à–∏–ª–æ—Å—è –∫–∞—Ä—Ç. –í–∑—è–ª–∏ –∫–∞—Ä—Ç—É: {card}",
        playerNoCardsNoDeck: "üÉè –£ –≤–∞—Å –Ω–µ–º–∞—î –∫–∞—Ä—Ç —ñ –≤ –∫–æ–ª–æ–¥—ñ –±—ñ–ª—å—à–µ –Ω–µ–º–∞—î –∫–∞—Ä—Ç.",
        botGuessed: "üéØ –ë–æ—Ç –≤–≥–∞–¥–∞–≤! –í–∏ –≤—ñ–¥–¥–∞—î—Ç–µ: {cards}",
        botCards: "–°–∫—Ä–∏–Ω—å–∫–∏ –±–æ—Ç–∞:",
        botNoCardsInHand: "ü§ñ –£ –±–æ—Ç–∞ –Ω–µ –±—É–ª–æ –∫–∞—Ä—Ç.",
        allBoxesCollected: "ü§ñ –£—Å—ñ —Å–∫—Ä–∏–Ω—å–∫–∏ –≤–∂–µ –∑—ñ–±—Ä–∞–Ω—ñ!",
        errorWebApp: "WebApp API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π ‚Äî —Å—Ç–æ—Ä—ñ–Ω–∫–∞ –Ω–µ –≤—ñ–¥–∫—Ä–∏—Ç–∞ —á–µ—Ä–µ–∑ Telegram.",
        resultSent: "–†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –±–æ—Ç—É ‚úÖ",
        errorSending: "–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –±–æ—Ç—É.",
        results: "–†–µ–∑—É–ª—å—Ç–∞—Ç–∏:",
        winner: "–ü–µ—Ä–µ–º–æ–∂–µ—Ü—å:",
        gameOverWinner: "–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ü–µ—Ä–µ–º–æ–∂–µ—Ü—å: {winner} –∑ {boxes} —Å–∫—Ä–∏–Ω—å–∫–∞–º–∏",
        playerTookCards: "–ì—Ä–∞–≤–µ—Ü—å –∑–∞–±—Ä–∞–≤ —É {fromPlayer} –∫–∞—Ä—Ç–∏: {cards}",
        botTookCards: "–ë–æ—Ç –∑–∞–±—Ä–∞–≤ —É {fromPlayer} –∫–∞—Ä—Ç–∏: {cards}",
        botTurn: "–•—ñ–¥ –±–æ—Ç–∞...",
        playerTookFromDeck: "–ì—Ä–∞–≤–µ—Ü—å –≤–∑—è–≤ –∫–∞—Ä—Ç—É –∑ –∫–æ–ª–æ–¥–∏: {card}",
        youGuessed: "–í–∏ –≤–≥–∞–¥–∞–ª–∏!",
        youMadeAMistake: "–í–∏ –ø–æ–º–∏–ª–∏–ª–∏—Å—å!",
        botPassedTurn: "–•—ñ–¥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –¥–æ –±–æ—Ç–∞.",
        deckEmpty: "–ö–æ–ª–æ–¥–∞ –ø–æ—Ä–æ–∂–Ω—è."
      },
      de: {
        title: "Das Kisten-Spiel",
        player: "Spieler",
        bot: "Bot",
        gameTitle: "Das Kisten-Spiel",
        gameInfo: "Spielinformationen",
        currentPlayer: "Aktueller Spieler:",
        playerBoxes: "Kisten des Spielers:",
        botBoxes: "Kisten des Bots:",
        deckCount: "Karten im Stapel:",
        yourCards: "Ihre Karten:",
        controls: "Steuerung",
        rankSelection: "W√§hlen Sie den Wert der Karte, die Sie anfragen m√∂chten:",
        countSelection: "W√§hlen Sie die Anzahl der Karten:",
        suitSelection: "W√§hlen Sie die Farben:",
        selectedSuits: "Ausgew√§hlte Farben:",
        submitRequest: "Anfrage best√§tigen",
        botTurnInfo: "Zug des Bots...",
        gameHistory: "Spielverlauf:",
        gameRules: "Spielregeln:",
        rule1: "Das Ziel des Spiels ist es, so viele 'Kisten' (4 Karten desselben Wertes) wie m√∂glich zu sammeln.",
        rule2: "Fragen Sie den Bot nach Karten eines bestimmten Wertes, einer Anzahl und einer Farbe.",
        rule3: "Wenn Sie richtig geraten haben, setzen Sie Ihren Zug fort, bis Sie einen Fehler machen.",
        rule4: "Wenn nicht, geht der Zug an den Bot √ºber.",
        rule5: "Das Spiel endet, wenn alle 9 Kisten gesammelt sind oder wenn keine Karten mehr vorhanden sind.",
        newGame: "Neues Spiel",
        sendResult: "Ergebnis an den Bot senden",
        gameOver: "Spiel beendet!",
        playAgain: "Nochmal spielen",
        gameStarted: "Spiel gestartet!",
        initialCardsDealt: "Anfangskarten an die Spieler ausgeteilt",
        playerCollectedBox: "Sie haben eine Kiste {rank} gesammelt!",
        botCollectedBox: "Der Bot hat eine Kiste {rank} gesammelt!",
        playerAsk: "Spieler fragte nach Karten {rank}",
        playerAskCount: "Spieler fragte nach {count} Karten des Wertes {rank}",
        playerChoseSuits: "Spieler w√§hlte Farben: {suits}",
        botAsk: "Bot fragt: \"Haben Sie {rank}?\"",
        botAskCount: "Bot fragt: \"Haben Sie {count} {rank}s?\"",
        botAskSuits: "Bot fragt: \"Haben Sie {count} {rank}s der Farben {suits}?\"",
        botTurnThinking: "ü§ñ Der Bot denkt √ºber seinen Zug nach...",
        botDrawsFromDeck: "ü§ñ Bot hat eine Karte vom Stapel genommen.",
        playerDrewFromDeck: "Sie haben eine Karte vom Stapel genommen: {card}",
        botNoCards: "Sie haben diese Karten nicht.",
        botDrawsFromDeckMessage: "üì© Bot hat eine Karte vom Stapel genommen.",
        playerMistakeCount: "Sie haben sich geirrt! Der Bot hat {count} von {rank}.",
        playerMistakeSuits: "Sie haben sich geirrt!",
        noMoreCardsInDeck: "Es sind keine Karten mehr im Stapel.",
        playerGuessed: "üéâ Sie haben richtig geraten! Der Bot hat Ihnen gegeben: {cards}",
        yourNewCards: "üìã Ihre neuen Karten: {cards}",
        playerNoCardsDraw: "üÉè Sie haben keine Karten mehr. Sie haben eine Karte genommen: {card}",
        playerNoCardsNoDeck: "üÉè Sie haben keine Karten mehr und der Stapel ist leer.",
        botGuessed: "üéØ Der Bot hat richtig geraten! Sie geben ab: {cards}",
        botCards: "Kisten des Bots:",
        botNoCardsInHand: "ü§ñ Der Bot hatte keine Karten.",
        allBoxesCollected: "ü§ñ Alle Kisten wurden gesammelt!",
        errorWebApp: "WebApp API ist nicht verf√ºgbar ‚Äì die Seite wurde nicht √ºber Telegram ge√∂ffnet.",
        resultSent: "Ergebnis an den Bot gesendet ‚úÖ",
        errorSending: "Fehler beim Senden des Ergebnisses an den Bot.",
        results: "Ergebnisse:",
        winner: "Gewinner:",
        gameOverWinner: "Spiel beendet! Gewinner: {winner} mit {boxes} Kisten",
        playerTookCards: "Spieler nahm Karten von {fromPlayer}: {cards}",
        botTookCards: "Bot nahm Karten von {fromPlayer}: {cards}",
        botTurn: "Zug des Bots...",
        playerTookFromDeck: "Spieler hat eine Karte vom Stapel genommen: {card}",
        youGuessed: "Sie haben richtig geraten!",
        youMadeAMistake: "Sie haben sich geirrt!",
        botPassedTurn: "Der Zug geht an den Bot √ºber.",
        deckEmpty: "Der Stapel ist leer."
      },
      ru: {
        title: "–ò–≥—Ä–∞ '–°—É–Ω–¥—É—á–∫–∏'",
        player: "–ò–≥—Ä–æ–∫",
        bot: "–ë–æ—Ç",
        gameTitle: "–ò–≥—Ä–∞ '–°—É–Ω–¥—É—á–∫–∏'",
        gameInfo: "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–≥—Ä–µ",
        currentPlayer: "–¢–µ–∫—É—â–∏–π –∏–≥—Ä–æ–∫:",
        playerBoxes: "–°—É–Ω–¥—É—á–∫–∏ –∏–≥—Ä–æ–∫–∞:",
        botBoxes: "–°—É–Ω–¥—É—á–∫–∏ –±–æ—Ç–∞:",
        deckCount: "–ö–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ:",
        yourCards: "–í–∞—à–∏ –∫–∞—Ä—Ç—ã:",
        controls: "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ",
        rankSelection: "–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–∏–Ω–∞–ª –∫–∞—Ä—Ç—ã, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø—Ä–æ—Å–∏—Ç—å:",
        countSelection: "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç:",
        suitSelection: "–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Å—Ç–∏:",
        selectedSuits: "–í—ã–±—Ä–∞–Ω–æ –º–∞—Å—Ç–µ–π:",
        submitRequest: "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–ø—Ä–æ—Å",
        botTurnInfo: "–•–æ–¥ –±–æ—Ç–∞...",
        gameHistory: "–ò—Å—Ç–æ—Ä–∏—è –∏–≥—Ä—ã:",
        gameRules: "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã:",
        rule1: "–¶–µ–ª—å –∏–≥—Ä—ã - —Å–æ–±—Ä–∞—Ç—å –∫–∞–∫ –º–æ–∂–Ω–æ –±–æ–ª—å—à–µ '—Å—É–Ω–¥—É—á–∫–æ–≤' (4 –∫–∞—Ä—Ç—ã –æ–¥–Ω–æ–≥–æ –Ω–æ–º–∏–Ω–∞–ª–∞).",
        rule2: "–ó–∞–ø—Ä–∞—à–∏–≤–∞–π—Ç–µ —É –±–æ—Ç–∞ –∫–∞—Ä—Ç—ã –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –Ω–æ–º–∏–Ω–∞–ª–∞, –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏ –º–∞—Å—Ç–∏.",
        rule3: "–ï—Å–ª–∏ –≤—ã —É–≥–∞–¥–∞–ª–∏, –ø—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ö–æ–¥–∏—Ç—å, –ø–æ–∫–∞ –Ω–µ –æ—à–∏–±–µ—Ç–µ—Å—å.",
        rule4: "–ï—Å–ª–∏ –Ω–µ—Ç - —Ö–æ–¥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ –±–æ—Ç—É.",
        rule5: "–ò–≥—Ä–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —Å–æ–±—Ä–∞–Ω—ã –≤—Å–µ 9 —Å—É–Ω–¥—É—á–∫–æ–≤ –∏–ª–∏ –∫–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∫–∞—Ä—Ç—ã.",
        newGame: "–ù–æ–≤–∞—è –∏–≥—Ä–∞",
        sendResult: "–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±–æ—Ç—É",
        gameOver: "–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!",
        playAgain: "–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞",
        gameStarted: "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!",
        initialCardsDealt: "–†–∞–∑–¥–∞–Ω—ã –Ω–∞—á–∞–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞–º",
        playerCollectedBox: "–í—ã —Å–æ–±—Ä–∞–ª–∏ —Å—É–Ω–¥—É—á–æ–∫ {rank}!",
        botCollectedBox: "–ë–æ—Ç —Å–æ–±—Ä–∞–ª —Å—É–Ω–¥—É—á–æ–∫ {rank}!",
        playerAsk: "–ò–≥—Ä–æ–∫ –∑–∞–ø—Ä–æ—Å–∏–ª –∫–∞—Ä—Ç—ã {rank}",
        playerAskCount: "–ò–≥—Ä–æ–∫ –∑–∞–ø—Ä–æ—Å–∏–ª {count} –∫–∞—Ä—Ç—ã {rank}",
        playerChoseSuits: "–ò–≥—Ä–æ–∫ –≤—ã–±—Ä–∞–ª –º–∞—Å—Ç–∏: {suits}",
        botAsk: "–ë–æ—Ç —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç: \"–£ –≤–∞—Å –µ—Å—Ç—å {rank}?\"",
        botAskCount: "–ë–æ—Ç —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç: \"–£ –≤–∞—Å –µ—Å—Ç—å {count} {rank}?\"",
        botAskSuits: "–ë–æ—Ç —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç: \"–£ –≤–∞—Å –µ—Å—Ç—å {count} {rank} –º–∞—Å—Ç–µ–π {suits}?\"",
        botTurnThinking: "ü§ñ –ë–æ—Ç –æ–±–¥—É–º—ã–≤–∞–µ—Ç —Å–≤–æ–π —Ö–æ–¥...",
        botDrawsFromDeck: "ü§ñ –ë–æ—Ç –ø–æ–ª—É—á–∏–ª –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã.",
        playerDrewFromDeck: "–í—ã –≤–∑—è–ª–∏ –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã: {card}",
        botNoCards: "–£ –≤–∞—Å –Ω–µ—Ç —Ç–∞–∫–∏—Ö –∫–∞—Ä—Ç.",
        botDrawsFromDeckMessage: "üì© –ë–æ—Ç –ø–æ–ª—É—á–∏–ª –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã.",
        playerMistakeCount: "–í—ã –æ—à–∏–±–ª–∏—Å—å! –£ –±–æ—Ç–∞ {count} {rank}.",
        playerMistakeSuits: "–í—ã –æ—à–∏–±–ª–∏—Å—å!",
        noMoreCardsInDeck: "–í –∫–æ–ª–æ–¥–µ –±–æ–ª—å—à–µ –Ω–µ—Ç –∫–∞—Ä—Ç.",
        playerGuessed: "üéâ –í—ã —É–≥–∞–¥–∞–ª–∏! –ë–æ—Ç –æ—Ç–¥–∞–ª –≤–∞–º: {cards}",
        yourNewCards: "üìã –í–∞—à–∏ –Ω–æ–≤—ã–µ –∫–∞—Ä—Ç—ã: {cards}",
        playerNoCardsDraw: "üÉè –£ –≤–∞—Å –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –∫–∞—Ä—Ç. –í–∑—è–ª–∏ –∫–∞—Ä—Ç—É: {card}",
        playerNoCardsNoDeck: "üÉè –£ –≤–∞—Å –Ω–µ—Ç –∫–∞—Ä—Ç –∏ –≤ –∫–æ–ª–æ–¥–µ –±–æ–ª—å—à–µ –Ω–µ—Ç –∫–∞—Ä—Ç.",
        botGuessed: "üéØ –ë–æ—Ç —É–≥–∞–¥–∞–ª! –í—ã –æ—Ç–¥–∞–µ—Ç–µ: {cards}",
        botCards: "–°—É–Ω–¥—É—á–∫–∏ –±–æ—Ç–∞:",
        botNoCardsInHand: "ü§ñ –£ –±–æ—Ç–∞ –Ω–µ –±—ã–ª–æ –∫–∞—Ä—Ç.",
        allBoxesCollected: "ü§ñ –í—Å–µ —Å—É–Ω–¥—É—á–∫–∏ —É–∂–µ —Å–æ–±—Ä–∞–Ω—ã!",
        errorWebApp: "WebApp API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–∞ —á–µ—Ä–µ–∑ Telegram.",
        resultSent: "–†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –±–æ—Ç—É ‚úÖ",
        errorSending: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –±–æ—Ç—É.",
        results: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:",
        winner: "–ü–æ–±–µ–¥–∏—Ç–µ–ª—å:",
        gameOverWinner: "–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: {winner} —Å {boxes} —Å—É–Ω–¥—É—á–∫–∞–º–∏",
        playerTookCards: "–ò–≥—Ä–æ–∫ –∑–∞–±—Ä–∞–ª —É {fromPlayer} –∫–∞—Ä—Ç—ã: {cards}",
        botTookCards: "–ë–æ—Ç –∑–∞–±—Ä–∞–ª —É {fromPlayer} –∫–∞—Ä—Ç—ã: {cards}",
        botTurn: "–•–æ–¥ –±–æ—Ç–∞...",
        playerTookFromDeck: "–ò–≥—Ä–æ–∫ –≤–∑—è–ª –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã: {card}",
        youGuessed: "–í—ã —É–≥–∞–¥–∞–ª–∏!",
        youMadeAMistake: "–í—ã –æ—à–∏–±–ª–∏—Å—å!",
        botPassedTurn: "–•–æ–¥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ –±–æ—Ç—É.",
        deckEmpty: "–ö–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞."
      },
      es: {
        title: "El Juego de las Cajas",
        player: "Jugador",
        bot: "Bot",
        gameTitle: "El Juego de las Cajas",
        gameInfo: "Informaci√≥n del Juego",
        currentPlayer: "Jugador actual:",
        playerBoxes: "Cajas del Jugador:",
        botBoxes: "Cajas del Bot:",
        deckCount: "Cartas en el mazo:",
        yourCards: "Tus cartas:",
        controls: "Controles",
        rankSelection: "Elige el valor de la carta que quieres pedir:",
        countSelection: "Elige la cantidad de cartas:",
        suitSelection: "Elige los palos:",
        selectedSuits: "Palos seleccionados:",
        submitRequest: "Confirmar solicitud",
        botTurnInfo: "Turno del bot...",
        gameHistory: "Historial del juego:",
        gameRules: "Reglas del juego:",
        rule1: "El objetivo del juego es recoger tantas 'cajas' (4 cartas del mismo valor) como sea posible.",
        rule2: "Pide al bot cartas de un cierto valor, cantidad y palo.",
        rule3: "Si adivinas correctamente, contin√∫a tu turno hasta que te equivoques.",
        rule4: "Si no, el turno pasa al bot.",
        rule5: "El juego termina cuando se recogen las 9 cajas o cuando no hay m√°s cartas.",
        newGame: "Nueva partida",
        sendResult: "Enviar resultado al bot",
        gameOver: "¬°Juego terminado!",
        playAgain: "Jugar de nuevo",
        gameStarted: "¬°Juego iniciado!",
        initialCardsDealt: "Cartas iniciales repartidas a los jugadores",
        playerCollectedBox: "¬°Has recogido una caja {rank}!",
        botCollectedBox: "¬°El bot ha recogido una caja {rank}!",
        playerAsk: "El jugador pidi√≥ cartas {rank}",
        playerAskCount: "El jugador pidi√≥ {count} cartas de valor {rank}",
        playerChoseSuits: "El jugador eligi√≥ palos: {suits}",
        botAsk: "El bot pregunta: \"¬øTienes {rank}?\"",
        botAskCount: "El bot pregunta: \"¬øTienes {count} {rank}?\"",
        botAskSuits: "El bot pregunta: \"¬øTienes {count} {rank} de palos {suits}?\"",
        botTurnThinking: "ü§ñ El bot est√° pensando en su jugada...",
        botDrawsFromDeck: "ü§ñ El bot recibi√≥ una carta del mazo.",
        playerDrewFromDeck: "Has tomado una carta del mazo: {card}",
        botNoCards: "No tienes esas cartas.",
        botDrawsFromDeckMessage: "üì© El bot recibi√≥ una carta del mazo.",
        playerMistakeCount: "¬°Te equivocaste! El bot tiene {count} de {rank}.",
        playerMistakeSuits: "¬°Te equivocaste!",
        noMoreCardsInDeck: "No hay m√°s cartas en el mazo.",
        playerGuessed: "üéâ ¬°Adivinaste correctamente! El bot te dio: {cards}",
        yourNewCards: "üìã Tus nuevas cartas: {cards}",
        playerNoCardsDraw: "üÉè No te quedan cartas. Has tomado una carta: {card}",
        playerNoCardsNoDeck: "üÉè No te quedan cartas y el mazo est√° vac√≠o.",
        botGuessed: "üéØ ¬°El bot adivin√≥ correctamente! Entregas: {cards}",
        botCards: "Cajas del bot:",
        botNoCardsInHand: "ü§ñ El bot no ten√≠a cartas.",
        allBoxesCollected: "ü§ñ ¬°Todas las cajas han sido recogidas!",
        errorWebApp: "La API de WebApp no est√° disponible, la p√°gina no se abri√≥ a trav√©s de Telegram.",
        resultSent: "Resultado enviado al bot ‚úÖ",
        errorSending: "Error al enviar el resultado al bot.",
        results: "Resultados:",
        winner: "Ganador:",
        gameOverWinner: "¬°Juego terminado! Ganador: {winner} con {boxes} cajas",
        playerTookCards: "El jugador tom√≥ cartas de {fromPlayer}: {cards}",
        botTookCards: "Bot tom√≥ cartas de {fromPlayer}: {cards}",
        botTurn: "Turno del bot...",
        playerTookFromDeck: "El jugador tom√≥ una carta del mazo: {card}",
        youGuessed: "Adivinaste correctamente!",
        youMadeAMistake: "Te equivocaste!",
        botPassedTurn: "El turno pasa al bot.",
        deckEmpty: "El mazo est√° vac√≠o."
      },
    };

    // telegram webapp SDK
    const tg = window.Telegram?.WebApp;
    if (tg) {
      try {
        tg.expand();
      } catch(e) {}
    }

    class SkrynkyGame {
      constructor(players = ["–ì—Ä–∞–≤–µ—Ü—å", "–ë–æ—Ç"], deckSize = 36) {
        this.players = players;
        this.currentPlayerIdx = 0;
        this.deck = this._generateDeck(deckSize);
        this.hands = { "–ì—Ä–∞–≤–µ—Ü—å": [], "–ë–æ—Ç": [] };
        this.boxes = { "–ì—Ä–∞–≤–µ—Ü—å": 0, "–ë–æ—Ç": 0 };
        this.usedBoxes = new Set();
        this.collectedBoxes = { "–ì—Ä–∞–≤–µ—Ü—å": [], "–ë–æ—Ç": [] };
        this.gameHistory = [];
        this.addToHistory("system", "gameStarted");
        this.dealCards();
      }

      _generateDeck(size) {
        const allRanks = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const ranks = allRanks.slice(0, size / 4);
        const suits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        return ranks.flatMap(rank => suits.map(suit => `${rank}${suit}`));
      }

      dealCards() {
        this.shuffleDeck();
        for (let i = 0; i < 4; i++) {
          for (const player of this.players) {
            if (this.deck.length > 0) {
              const card = this.deck.pop();
              this.hands[player].push(card);
              this._checkBoxesAfterDeal(player, card.slice(0, -1));
            }
          }
        }
        this.addToHistory("system", "initialCardsDealt");
      }

      getPlayerCardsByRank(player, rank) {
        return this.hands[player].filter(card => card.startsWith(rank));
      }

      shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
      }

      _checkBoxesAfterDeal(player, rank) {
        if (this.usedBoxes.has(rank)) return false;

        const cards = this.hands[player].filter(card => card.startsWith(rank));
        if (cards.length === 4) {
          this.boxes[player]++;
          this.usedBoxes.add(rank);
          this.collectedBoxes[player].push(rank);
          this.hands[player] = this.hands[player].filter(card => !card.startsWith(rank));
          this.addToHistory("system", `${player === "–ì—Ä–∞–≤–µ—Ü—å" ? "playerCollectedBox" : "botCollectedBox"}`, { rank });
          return true;
        }
        return false;
      }

      checkBoxes(player) {
        const ranks = this.hands[player].map(card => card.slice(0, -1));
        let changed = false;

        for (const rank of [...new Set(ranks)]) {
          if (!this.usedBoxes.has(rank) && ranks.filter(r => r === rank).length === 4) {
            this.boxes[player]++;
            this.usedBoxes.add(rank);
            this.collectedBoxes[player].push(rank);
            this.hands[player] = this.hands[player].filter(card => !card.startsWith(rank));
            this.addToHistory("system", `${player === "–ì—Ä–∞–≤–µ—Ü—å" ? "playerCollectedBox" : "botCollectedBox"}`, { rank });
            changed = true;
          }
        }
        return changed;
      }

      drawCard(player) {
        if (this.deck.length === 0) {
          return { success: false, collected: false, card: null };
        }

        const card = this.deck.pop();
        this.hands[player].push(card);
        const collected = this._checkBoxesAfterDeal(player, card.slice(0, -1));

        const role = player === "–ì—Ä–∞–≤–µ—Ü—å" ? "player" : "bot";
        const messageKey = role === "player" ? "playerTookFromDeck" : "botDrawsFromDeck";

        this.addToHistory(role, messageKey, { card });

        return { success: true, collected, card };
      }

      takeCards(fromPlayer, rank) {
        const cards = this.hands[fromPlayer].filter(card => card.startsWith(rank));
        this.hands[fromPlayer] = this.hands[fromPlayer].filter(card => !card.startsWith(rank));

        this.addToHistory(fromPlayer === "–ì—Ä–∞–≤–µ—Ü—å" ? "bot" : "player",
          fromPlayer === "–ì—Ä–∞–≤–µ—Ü—å" ? "botTookCards" : "playerTookCards", {
            fromPlayer: fromPlayer === "–ì—Ä–∞–≤–µ—Ü—å" ? translations[ui.lang].player : translations[ui.lang].bot,
            cards: cards.join(', '),
          });

        return cards;
      }

      isGameOver() {
        if (this.boxes["–ì—Ä–∞–≤–µ—Ü—å"] + this.boxes["–ë–æ—Ç"] === 9) {
          return true;
        }

        if (this.deck.length === 0) {
          return Object.values(this.hands).every(hand => hand.length === 0);
        }

        return false;
      }

      nextTurn() {
        this.currentPlayerIdx = (this.currentPlayerIdx + 1) % this.players.length;

        while (this.hands[this.players[this.currentPlayerIdx]].length === 0 && !this.isGameOver()) {
          if (this.deck.length === 0) {
            this.currentPlayerIdx = (this.currentPlayerIdx + 1) % this.players.length;
          } else {
            const result = this.drawCard(this.players[this.currentPlayerIdx]);
            if (!result.collected) {
              this.currentPlayerIdx = (this.currentPlayerIdx + 1) % this.players.length;
            }
          }
        }
      }

      addToHistory(type, messageKey, replacements = {}) {
        const timestamp = new Date().toLocaleTimeString();
        this.gameHistory.push({ type, messageKey, replacements, timestamp });
      }

      getCurrentPlayer() {
        return this.players[this.currentPlayerIdx];
      }
    }

    class GameUI {
      constructor() {
        this.game = null;
        this.selectedSuits = [];
        this.requiredCount = 0;
        this.lang = this._getLang();
        this.initElements();
        this.bindEvents();
        this.startNewGame();
        this.initTelegramUser();
        this._localize();
      }
      
      _getLang() {
        const userLang = navigator.language.split('-')[0];
        const supportedLangs = Object.keys(translations);
        return supportedLangs.includes(userLang) ? userLang : 'en';
      }
      
      _localize() {
        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.getAttribute('data-i18n');
          if (translations[this.lang] && translations[this.lang][key]) {
            el.textContent = translations[this.lang][key];
          }
        });
      }

      localize(key, replacements = {}) {
        let message = translations[this.lang]?.[key] || key;
        for (const placeholder in replacements) {
          const regex = new RegExp(`{${placeholder}}`, 'g');
          message = message.replace(regex, replacements[placeholder]);
        }
        return message;
      }

      initTelegramUser() {
        if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
          const u = tg.initDataUnsafe.user;
          const name = u.username ? `@${u.username}` : (u.first_name || '–ì—Ä–∞–≤–µ—Ü—å');
          document.getElementById('current-player').textContent = name;
          this.telegramUser = name;
        }
      }

      initElements() {
        this.elements = {
          langSelect: document.getElementById('lang-select'),
          currentPlayer: document.getElementById('current-player'),
          playerBoxes: document.getElementById('player-boxes'),
          playerBoxesList: document.getElementById('player-boxes-list'),
          botBoxes: document.getElementById('bot-boxes'),
          botBoxesList: document.getElementById('bot-boxes-list'),
          deckCount: document.getElementById('deck-count'),
          playerCards: document.getElementById('player-cards'),
          rankSelection: document.getElementById('rank-selection'),
          countSelection: document.getElementById('count-selection'),
          suitSelection: document.getElementById('suit-selection'),
          rankButtons: document.getElementById('rank-buttons'),
          selectedSuits: document.getElementById('selected-suits'),
          submitRequest: document.getElementById('submit-request'),
          gameControls: document.getElementById('game-controls'),
          botTurnInfo: document.getElementById('bot-turn-info'),
          botMessages: document.getElementById('bot-messages'),
          newGameBtn: document.getElementById('new-game-btn'),
          sendResultBtn: document.getElementById('send-result-to-bot'),
          gameOverModal: document.getElementById('game-over-modal'),
          gameResult: document.getElementById('game-result'),
          playAgainBtn: document.getElementById('play-again-btn'),
          closeModal: document.querySelector('.close'),
          gameHistory: document.getElementById('game-history')
        };
      }

      bindEvents() {
        this.elements.langSelect.addEventListener('change', (e) => this.setLanguage(e.target.value));
        this.elements.newGameBtn.addEventListener('click', () => this.startNewGame());
        this.elements.playAgainBtn.addEventListener('click', () => this.startNewGame());
        this.elements.closeModal.addEventListener('click', () => this.closeModal());
        this.elements.sendResultBtn.addEventListener('click', () => this.sendResultToBot());

        document.addEventListener('click', (e) => {
          if (e.target === this.elements.gameOverModal) this.closeModal();
        });

        this.elements.rankButtons.addEventListener('click', (e) => {
          if (e.target.tagName === 'BUTTON' && e.target.dataset.rank) {
            this.handleRankSelection(e.target.dataset.rank);
          }
        });

        document.querySelectorAll('.count-btn').forEach(btn => {
          btn.addEventListener('click', () => this.handleCountSelection(btn.dataset.count));
        });

        document.querySelectorAll('.suit-btn').forEach(btn => {
          btn.addEventListener('click', () => this.handleSuitSelection(btn.dataset.suit));
        });

        this.elements.submitRequest.addEventListener('click', () => this.submitRequest());
      }
      
      setLanguage(lang) {
        this.lang = lang;
        this._localize();
        this.updateUI();
        this.setupRankButtons();
        // Update any dynamic text based on the new language
        if (this.game) {
            this.elements.botMessages.innerHTML = `<p>${this.localize('botTurnThinking')}</p>`;
            this.updateGameHistory();
        }
      }

      startNewGame() {
        this.game = new SkrynkyGame();
        this.resetRequestState();
        this.closeModal();
        this.resetUI();
        this.updateUI();
        this.setupRankButtons();
        this.updateGameHistory();
        if (tg) {
          this.elements.sendResultBtn.style.display = 'none';
        }
      }

      resetUI() {
        this.elements.botMessages.innerHTML = '';
        this.elements.botTurnInfo.style.display = 'none';
        this.elements.gameControls.style.display = 'block';
        this.elements.rankSelection.style.display = 'block';
        this.elements.countSelection.style.display = 'none';
        this.elements.suitSelection.style.display = 'none';
        this.selectedSuits = [];
        this.requiredCount = 0;
      }

      setupRankButtons() {
        this.elements.rankButtons.innerHTML = '';
        const availableRanks = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'].filter(rank => !this.game.usedBoxes.has(rank));
        if (availableRanks.length === 0) return;
        availableRanks.forEach(rank => {
          const btn = document.createElement('button');
          btn.textContent = rank;
          btn.dataset.rank = rank;
          this.elements.rankButtons.appendChild(btn);
        });
      }

      handleRankSelection(rank) {
        const botCards = this.game.hands["–ë–æ—Ç"].filter(card => card.startsWith(rank));
        this.game.addToHistory("player", "playerAsk", { rank });
        if (botCards.length === 0) {
          this.handleNoCardsFromBot(rank);
          return;
        }
        this.game.playerState = { rank };
        this.elements.rankSelection.style.display = 'none';
        this.elements.countSelection.style.display = 'block';
      }

      handleCountSelection(count) {
        const rank = this.game.playerState.rank;
        const botCards = this.game.getPlayerCardsByRank("–ë–æ—Ç", rank);
        this.game.addToHistory("player", "playerAskCount", { count, rank });

        if (botCards.length !== parseInt(count)) {
          this.game.addToHistory("player", "playerMistakeCount", { count: botCards.length, rank });
          const result = this.game.drawCard("–ì—Ä–∞–≤–µ—Ü—å");
          let message = `${this.localize("youMadeAMistake")}! ${this.localize("playerMistakeCount", { count: botCards.length, rank })}. `;
          if (result.success) {
            message += `${this.localize("playerDrewFromDeck", { card: result.card })}`;
            if (result.collected) message += `<br>‚ö°Ô∏è ${this.localize("playerCollectedBox", { rank: result.card.slice(0, -1)})}`;
          } else message += `${this.localize("noMoreCardsInDeck")}`;
          this.showMessage(message);
          this.game.nextTurn();
          this.resetRequestState();
          this.updateUI();
          setTimeout(() => this.processTurn(), 1000);
          return;
        }

        this.requiredCount = parseInt(count);
        this.game.playerState.count = count;
        this.elements.countSelection.style.display = 'none';
        this.elements.suitSelection.style.display = 'block';
        this.elements.selectedSuits.innerHTML = '';
        this.selectedSuits = [];
        this.elements.submitRequest.disabled = true;
      }

      handleSuitSelection(suit) {
        if (this.selectedSuits.includes(suit)) return;
        if (this.selectedSuits.length >= this.requiredCount) return;
        this.selectedSuits.push(suit);
        this.updateSelectedSuitsDisplay();
        if (this.selectedSuits.length === this.requiredCount) this.elements.submitRequest.disabled = false;
      }

      updateSelectedSuitsDisplay() {
        this.elements.selectedSuits.innerHTML = this.localize('selectedSuits') + ' ' +
          this.selectedSuits.map(suit => {
            const colorClass = suit === '‚ô•' || suit === '‚ô¶' ? 'hearts' : 'clubs';
            return `<span class="${colorClass}">${suit}</span>`;
          }).join(', ');
      }

      submitRequest() {
        const rank = this.game.playerState.rank;
        const botCards = this.game.getPlayerCardsByRank("–ë–æ—Ç", rank);
        const botSuits = botCards.map(card => card.slice(-1));
        this.game.addToHistory("player", "playerChoseSuits", { suits: this.selectedSuits.join(', ') });
        if (this.arraysEqual(this.selectedSuits.sort(), botSuits.sort())) {
          this.handleSuccessfulGuess(rank, botCards);
        } else {
          this.handleFailedGuess(rank);
        }
        this.elements.suitSelection.style.display = 'none';
        this.elements.rankSelection.style.display = 'block';
        this.selectedSuits = [];
      }

      arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++)
          if (a[i] !== b[i]) return false;
        return true;
      }

      handleSuccessfulGuess(rank, takenCards) {
        const player = "–ì—Ä–∞–≤–µ—Ü—å";
        const cardsTaken = this.game.takeCards("–ë–æ—Ç", rank);
        this.game.hands[player].push(...cardsTaken);
        const collectedBefore = this.game.boxes[player];
        this.game.checkBoxes(player);

        let message = `${this.localize("youGuessed")}! ${this.localize("playerGuessed", { cards: cardsTaken.join(', ') })}<br>`;
        message += `${this.localize("yourNewCards", { cards: this.game.hands[player].sort().join(', ') })}`;

        if (this.game.boxes[player] > collectedBefore) {
          const newBox = this.game.collectedBoxes[player][this.game.collectedBoxes[player].length - 1];
          message += `<br>‚ö°Ô∏è ${this.localize("playerCollectedBox", { rank: newBox })}!`;
        }

        this.showMessage(message);
        this.updateUI();

        if (this.game.isGameOver()) this.endGame();
        else {
          if (this.game.hands[player].length === 0) this.handlePlayerNoCards();
          else this.processTurn();
        }
      }

      handleFailedGuess(rank) {
        const player = "–ì—Ä–∞–≤–µ—Ü—å";
        const result = this.game.drawCard(player);
        let message = `${this.localize("youMadeAMistake")}! `;
        if (result.success) {
          message += `${this.localize("playerDrewFromDeck", { card: result.card })}<br>`;
          if (result.collected) message += `<br>‚ö°Ô∏è ${this.localize("playerCollectedBox", { rank: result.card.slice(0, -1)})}`;
          message += `üìã ${this.localize("yourCards")}: ${this.game.hands[player].sort().join(', ')}`;
        } else {
          message += `${this.localize("noMoreCardsInDeck")}.`;
        }
        this.showMessage(message);
        this.game.nextTurn();
        this.resetRequestState();
        this.updateUI();
        setTimeout(() => this.processTurn(), 1000);
      }

      handleNoCardsFromBot(rank) {
        const player = "–ì—Ä–∞–≤–µ—Ü—å";
        const result = this.game.drawCard(player);
        let message = `‚ùå ${this.localize("botNoCards")}. `;
        if (result.success) {
          message += `${this.localize("playerDrewFromDeck", { card: result.card })}<br>`;
          if (result.collected) message += `<br>‚ö°Ô∏è ${this.localize("playerCollectedBox", { rank: result.card.slice(0, -1)})}`;
        } else {
          message += `${this.localize("noMoreCardsInDeck")}.`;
        }
        this.showMessage(message);
        this.game.nextTurn();
        this.resetRequestState();
        this.updateUI();
        setTimeout(() => this.processTurn(), 1000);
      }

      handlePlayerNoCards() {
        const player = "–ì—Ä–∞–≤–µ—Ü—å";
        if (this.game.deck.length > 0) {
          const result = this.game.drawCard(player);
          if (result.success) {
            let message = `üÉè ${this.localize("playerNoCardsDraw", { card: result.card })}`;
            if (result.collected) message += `<br>‚ö°Ô∏è ${this.localize("playerCollectedBox", { rank: result.card.slice(0, -1)})}`;
            this.showMessage(message);
            this.updateUI();
            if (this.game.isGameOver()) this.endGame();
            else this.processTurn();
          } else {
            this.showMessage(this.localize("playerNoCardsNoDeck"));
            this.game.nextTurn();
            this.processTurn();
          }
        } else {
          this.showMessage(this.localize("playerNoCardsNoDeck"));
          this.game.nextTurn();
          this.processTurn();
        }
      }

      processTurn() {
        if (this.game.isGameOver()) {
          this.endGame();
          return;
        }
        if (this.game.getCurrentPlayer() === "–ì—Ä–∞–≤–µ—Ü—å") {
          this.resetRequestState();
          this.playerTurn();
        } else this.botTurn();
      }

      playerTurn() {
        this.elements.botTurnInfo.style.display = 'none';
        this.elements.gameControls.style.display = 'block';
        if (this.game.hands["–ì—Ä–∞–≤–µ—Ü—å"].length === 0) {
          this.handlePlayerNoCards();
          return;
        }
        this.updateUI();
        this.setupRankButtons();
      }

      botTurn() {
        this.elements.gameControls.style.display = 'none';
        this.elements.botTurnInfo.style.display = 'block';
        this.elements.botMessages.innerHTML = `<p>${this.localize('botTurnThinking')}</p>`;
        setTimeout(() => this.executeBotTurn(), 1500);
      }

      executeBotTurn() {
        const bot = "–ë–æ—Ç";
        const player = "–ì—Ä–∞–≤–µ—Ü—å";

        if (this.game.hands[bot].length === 0) {
          if (this.game.deck.length > 0) {
            const result = this.game.drawCard(bot);
            let message = `${this.localize("botNoCardsInHand")} `;
            if (result.success) {
              message += `${this.localize("botDrawsFromDeck")}.`;
              if (result.collected) {
                message += `<br>üò± ${this.localize("botCollectedBox", { rank: result.card.slice(0, -1) })}!`;
              }
              this.showBotMessage(message);
              this.processTurn();
            }
          } else {
            this.showBotMessage(`${this.localize("botNoCardsInHand")} ${this.localize("deckEmpty")}.`);
            this.game.nextTurn();
            this.processTurn();
          }
          return;
        }

        const availableRanks = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
          .filter(rank => !this.game.usedBoxes.has(rank));

        if (availableRanks.length === 0) {
          this.showBotMessage(this.localize("allBoxesCollected"));
          this.game.nextTurn();
          this.processTurn();
          return;
        }

        const rank = availableRanks[Math.floor(Math.random() * availableRanks.length)];
        this.game.addToHistory("bot", "botAsk", { rank });
        const playerCards = this.game.getPlayerCardsByRank(player, rank);

        if (playerCards.length === 0) {
          const result = this.game.drawCard(bot);
          let message = `${this.localize("botAsk", { rank })}<br>‚ùå ${this.localize("botNoCards")}.<br>`;
          if (result.success) {
            message += `${this.localize("botDrawsFromDeckMessage", { card: result.card })}`;
            if (result.collected) {
              message += `<br>üò± ${this.localize("botCollectedBox", { rank: result.card.slice(0, -1) })}!`;
            }
          } else {
            message += `${this.localize("noMoreCardsInDeck")}.`;
          }
          message += `<br>${this.localize("botBoxes")} ${this.game.boxes[bot]} (${this.game.collectedBoxes[bot].join(', ')})`;
          this.showBotMessage(message);
          this.game.nextTurn();
          this.processTurn();
          return;
        }

        const count = Math.floor(Math.random() * Math.min(4, playerCards.length)) + 1;
        this.game.addToHistory("bot", "botAskCount", { count, rank });

        if (playerCards.length !== count) {
          const result = this.game.drawCard(bot);
          let message = `${this.localize("botAskCount", { count, rank })}<br>‚ùå ${this.localize("playerMistakeCount", { count: playerCards.length, rank })}.<br>`;
          if (result.success) {
            message += `${this.localize("botDrawsFromDeckMessage", { card: result.card })}`;
            if (result.collected) {
              message += `<br>üò± ${this.localize("botCollectedBox", { rank: result.card.slice(0, -1) })}!`;
            }
          } else {
            message += `${this.localize("noMoreCardsInDeck")}.`;
          }
          message += `<br>${this.localize("botBoxes")} ${this.game.boxes[bot]} (${this.game.collectedBoxes[bot].join(', ')})`;
          this.showBotMessage(message);
          this.game.nextTurn();
          this.processTurn();
          return;
        }

        const suitsToTake = [...new Set(playerCards.map(card => card.slice(-1)))];
        const suitsText = suitsToTake.map(suit => {
          const colorClass = suit === '‚ô•' || suit === '‚ô¶' ? 'hearts' : 'clubs';
          return `<span class="${colorClass}">${suit}</span>`;
        }).join(', ');
        this.game.addToHistory("bot", "botAskSuits", { count, rank, suits: suitsToTake.join(', ') });
        const cardsTaken = this.game.takeCards(player, rank);
        this.game.hands[bot].push(...cardsTaken);
        const boxesBefore = this.game.boxes[bot];
        this.game.checkBoxes(bot);

        let message = `${this.localize("botGuessed", { cards: cardsTaken.join(', ') })}<br>`;
        message += `${this.localize("yourNewCards", { cards: this.game.hands[player].sort().join(', ') })}<br>`;
        message += `${this.localize("botBoxes")} ${this.game.boxes[bot]} (${this.game.collectedBoxes[bot].join(', ')})`;

        if (this.game.boxes[bot] > boxesBefore) {
          const newBox = this.game.collectedBoxes[bot][this.game.collectedBoxes[bot].length - 1];
          message += `<br>üò± ${this.localize("botCollectedBox", { rank: newBox })}!`;
        }
        this.showBotMessage(message);
        this.updateUI();

        if (this.game.isGameOver()) {
          this.endGame();
        } else {
          this.processTurn();
        }
      }

      showMessage(message) {
        this.elements.botMessages.innerHTML = `<p>${message}</p>`;
      }
      showBotMessage(message) {
        this.elements.botMessages.innerHTML = `<p>${message}</p>`;
      }

      updateUI() {
        this.elements.currentPlayer.textContent = this.telegramUser || this.localize(this.game.getCurrentPlayer() === "–ì—Ä–∞–≤–µ—Ü—å" ? "player" : "bot");
        this.elements.playerBoxes.textContent = this.game.boxes["–ì—Ä–∞–≤–µ—Ü—å"];
        this.elements.playerBoxesList.textContent = this.game.collectedBoxes["–ì—Ä–∞–≤–µ—Ü—å"].join(', ');
        this.elements.botBoxes.textContent = this.game.boxes["–ë–æ—Ç"];
        this.elements.botBoxesList.textContent = this.game.collectedBoxes["–ë–æ—Ç"].join(', ');
        this.elements.deckCount.textContent = this.game.deck.length;
        this.elements.selectedSuits.innerHTML = this.localize('selectedSuits') + ': ' +
          this.selectedSuits.map(suit => {
            const colorClass = suit === '‚ô•' || suit === '‚ô¶' ? 'hearts' : 'clubs';
            return `<span class="${colorClass}">${suit}</span>`;
          }).join(', ');
        this.elements.langSelect.value = this.lang;


        this.elements.playerCards.innerHTML = '';
        this.game.hands["–ì—Ä–∞–≤–µ—Ü—å"].sort().forEach(card => {
          const cardElement = document.createElement('div');
          cardElement.className = 'card';
          cardElement.textContent = card;
          const suit = card.slice(-1);
          cardElement.classList.add(suit === '‚ô•' || suit === '‚ô¶' ? 'hearts' : 'clubs');
          this.elements.playerCards.appendChild(cardElement);
        });

        this.updateGameHistory();
      }

      updateGameHistory() {
        this.elements.gameHistory.innerHTML = '';
        this.game.gameHistory.forEach(entry => {
          const logEntry = document.createElement('div');
          logEntry.className = `log-entry ${entry.type}-log`;
          const message = this.localize(entry.messageKey, entry.replacements);
          logEntry.innerHTML = `<strong>[${entry.timestamp}]</strong> ${message}`;
          this.elements.gameHistory.appendChild(logEntry);
        });
        this.elements.gameHistory.scrollTop = this.elements.gameHistory.scrollHeight;
      }

      endGame() {
        const winner = Object.entries(this.game.boxes).reduce((a, b) => a[1] > b[1] ? a : b);
        let resultHTML = `
          <p>${this.localize('results')}</p>
          <p>${this.localize('player')}: ${this.game.boxes["–ì—Ä–∞–≤–µ—Ü—å"]} (${this.game.collectedBoxes["–ì—Ä–∞–≤–µ—Ü—å"].join(', ')})</p>
          <p>${this.localize('bot')}: ${this.game.boxes["–ë–æ—Ç"]} (${this.game.collectedBoxes["–ë–æ—Ç"].join(', ')})</p>
          <h3>${this.localize('winner')} ${this.localize(winner[0] === '–ì—Ä–∞–≤–µ—Ü—å' ? 'player' : 'bot')}!</h3>
        `;
        this.elements.gameResult.innerHTML = resultHTML;
        this.openModal();
        this.game.addToHistory("system", "gameOverWinner", { winner: this.localize(winner[0] === '–ì—Ä–∞–≤–µ—Ü—å' ? 'player' : 'bot'), boxes: winner[1] });
        this.updateGameHistory();

        if (tg) {
          this.elements.sendResultBtn.style.display = 'inline-block';
        }
      }

      openModal() {
        this.elements.gameOverModal.style.display = 'block';
      }
      closeModal() {
        this.elements.gameOverModal.style.display = 'none';
      }

      resetRequestState() {
        this.elements.rankSelection.style.display = 'block';
        this.elements.countSelection.style.display = 'none';
        this.elements.suitSelection.style.display = 'none';
        this.selectedSuits = [];
        this.requiredCount = 0;
        delete this.game.playerState;
      }

      sendResultToBot() {
        if (!tg) {
          alert(this.localize('errorWebApp'));
          return;
        }
        const payload = {
          type: 'game_over',
          user: tg.initDataUnsafe?.user?.username || tg.initDataUnsafe?.user?.first_name || null,
          result: {
            playerBoxes: this.game.boxes["–ì—Ä–∞–≤–µ—Ü—å"],
            botBoxes: this.game.boxes["–ë–æ—Ç"],
            playerCollected: this.game.collectedBoxes["–ì—Ä–∞–≤–µ—Ü—å"],
            botCollected: this.game.collectedBoxes["–ë–æ—Ç"],
            deckLeft: this.game.deck.length
          },
          history: this.game.gameHistory.slice(-20)
        };
        try {
          tg.sendData(JSON.stringify(payload));
          this.showMessage(this.localize('resultSent'));
        } catch (e) {
          console.error('sendData error', e);
          this.showMessage(this.localize('errorSending'));
        }
      }
    }

    let ui;
    document.addEventListener('DOMContentLoaded', () => {
      ui = new GameUI();
    });
  </script>
</body>
</html>
